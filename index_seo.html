<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SEO Generator - NanoSite</title>
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, sans-serif; 
            max-width: 62.5rem; 
            margin: 0 auto; 
            padding: 1.25rem;
            line-height: 1.6;
        }
        .container { 
            background: #f8f9fa; 
            border-radius: 0.5rem; 
            padding: 1.25rem; 
            margin-bottom: 1.25rem;
        }
        .tabs {
            display: flex;
            border-bottom: 0.125rem solid #e9ecef;
            margin-bottom: 1.25rem;
        }
        .tab {
            padding: 0.625rem 1.25rem;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            border-bottom: 0.125rem solid transparent;
        }
        .tab.active {
            border-bottom-color: #007acc;
            color: #007acc;
            font-weight: 600;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .btn-primary { 
            background: #007acc; 
            color: white; 
            border: none; 
            padding: 0.75rem 1.5rem; 
            border-radius: 0.375rem; 
            cursor: pointer; 
            font-size: 1rem;
            margin-right: 0.625rem;
        }
        .btn-secondary {
            background: #6c757d;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 0.375rem;
            cursor: pointer;
            font-size: 1rem;
            margin-right: 0.625rem;
        }
        .btn-primary:hover { background: #005a9e; }
        .btn-secondary:hover { background: #545b62; }
        textarea { 
            width: 100%; 
            height: 25rem; 
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace; 
            font-size: 0.8125rem;
            border: 0.0625rem solid #ddd;
            border-radius: 0.25rem;
            padding: 0.625rem;
            resize: vertical;
        }
        .output-group {
            margin-bottom: 1.875rem;
        }
        .output-group h3 {
            margin-bottom: 0.625rem;
            color: #495057;
        }
        .success { color: #22c55e; font-weight: 600; }
        .error { color: #ef4444; font-weight: 600; }
        .warning { color: #f59e0b; font-weight: 600; }
        .config-preview {
            background: white;
            border: 0.0625rem solid #ddd;
            border-radius: 0.25rem;
            padding: 0.9375rem;
            margin-bottom: 1.25rem;
        }
        .config-preview h4 {
            margin-top: 0;
            color: #495057;
        }
        .config-item {
            margin-bottom: 0.5rem;
            font-family: monospace;
            font-size: 0.875rem;
        }
        .config-label {
            font-weight: 600;
            color: #6c757d;
            min-width: 7.5rem;
            display: inline-block;
        }
        .instructions {
            background: #e3f2fd;
            border-left: 0.25rem solid #2196f3;
            padding: 0.9375rem;
            margin-bottom: 1.25rem;
        }
        .instructions h4 {
            margin-top: 0;
            color: #1976d2;
        }
        .file-actions {
            display: flex;
            gap: 0.625rem;
            margin-bottom: 0.9375rem;
            flex-wrap: wrap;
        }
        /* GitHub controls: compact, cleaner */
        .gh-controls { display:flex; align-items:center; gap:0.5rem; flex-wrap:wrap; }
        .gh-field { display:flex; align-items:center; border:1px solid #d0d7de; background:#fff; border-radius:6px; overflow:hidden; height: 2.1rem; box-shadow: 0 1px 0 rgba(27,31,36,.04), inset 0 1px 0 rgba(255,255,255,.5); }
        .gh-prefix { height:100%; display:flex; align-items:center; padding:0 0.5rem; color:#57606a; background:#f6f8fa; border-right:1px solid #d0d7de; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', monospace; }
        .gh-input { border:0; outline:none; padding:0 0.5rem; min-width:16rem; flex:1 1 auto; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', monospace; height:100%; }
        .gh-field.error { border-color:#ef4444; background:#fff7f7; }
        .gh-field.valid { border-color:#1f883d; }
        .gh-select { border:1px solid #d0d7de; background:#fff; border-radius:6px; padding:0.35rem 2rem 0.35rem 0.6rem; min-width:12rem; height:2.1rem; outline:none; transition: border-color .15s ease, box-shadow .15s ease; -webkit-appearance:none; appearance:none; background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='14' height='14' viewBox='0 0 20 20'%3E%3Cpath fill='%2357606a' d='M5.516 7.548a.75.75 0 0 1 1.06 0L10 10.97l3.424-3.424a.75.75 0 1 1 1.06 1.06l-3.954 3.955a.75.75 0 0 1-1.06 0L5.516 8.608a.75.75 0 0 1 0-1.06Z'/%3E%3C/svg%3E"); background-repeat:no-repeat; background-position: right .5rem center; box-shadow: 0 1px 0 rgba(27,31,36,.04), inset 0 1px 0 rgba(255,255,255,.5); }
        .gh-select:focus { border-color:#0969da; box-shadow:0 0 0 3px rgba(9,105,218,.3); }
        .gh-select:disabled { background:#f6f8fa; color:#8c959f; }
        .btn-gh { background:#1f883d; color:#fff; border:1px solid rgba(27,31,36,0.15); border-radius:6px; padding:0.35rem 0.8rem; height:2.1rem; cursor:pointer; box-shadow: 0 1px 0 rgba(27,31,36,.1); }
        .btn-gh:hover { background:#1a7f37; }
        .btn-gh:active { background:#187432; }
        .btn-gh:disabled { background:#94d3a2; cursor:not-allowed; }
        .gh-inline-action { height:100%; padding:0 .55rem; border:0; border-left:1px solid #d0d7de; background:transparent; color:#0969da; cursor:pointer; }
        .gh-inline-action:hover { background:#f6f8fa; color:#054da7; }
        .btn-link { background:transparent; border:none; color:#0969da; cursor:pointer; padding:0 .25rem; height:2.1rem; text-decoration:underline; }
        .btn-link:hover { color:#054da7; text-decoration:underline; }
        .gh-status { display:flex; gap:0.5rem; align-items:center; min-height:1.2rem; margin-top:0.5rem; }
        .badge { display:inline-flex; align-items:center; gap:0.4rem; padding:0.12rem 0.5rem; border-radius:999px; font-size:0.75rem; line-height:1; }
        .badge.ok { background:#e8f5e9; color:#16a34a; }
        .badge.err { background:#fde8e8; color:#dc2626; }
        .badge.warn { background:#fff7ed; color:#f59e0b; }
        .spinner { width:12px; height:12px; border:2px solid #c9d1d9; border-top-color:#0969da; border-radius:50%; display:inline-block; animation: spin .8s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        /* Title + fullscreen help modal */
        .gh-titlebar { display:flex; align-items:center; gap:0.5rem; position: relative; }
        .info-btn { width:22px; height:22px; display:inline-flex; align-items:center; justify-content:center; border:1px solid #d0d7de; border-radius:50%; background:#fff; color:#57606a; cursor:pointer; padding:0; font-weight:600; font-size:12px; line-height:1; box-shadow: 0 1px 0 rgba(27,31,36,.04); }
        .info-btn:hover { background:#f6f8fa; }
        .info-btn:focus { outline:none; box-shadow:0 0 0 3px rgba(9,105,218,.3); border-color:#0969da; }
        html, body { height: 100%; }
        @supports (-webkit-touch-callout: none) {
            html, body { height: -webkit-fill-available; }
        }
        .gh-overlay { position: fixed; top:0; left:0; right:0; bottom:0; width:100vw; height:100vh; min-height: var(--vvh, 100vh); background: rgba(27,31,36,.38); backdrop-filter: blur(6px); -webkit-backdrop-filter: blur(6px); display:none; z-index: 1000; padding: clamp(12px, 4vw, 24px); overflow: auto; overscroll-behavior: contain; }
        @supports (height: 100dvh) { .gh-overlay { height: 100dvh; } }
        @supports (height: 100lvh) { .gh-overlay { height: 100lvh; } }
        .gh-overlay.open { display:grid; place-items: start center; }
        /* Soften the bottom edge on iOS Safari where browser UI can't be blurred */
        .gh-overlay::after { content:""; position: fixed; left:0; right:0; bottom:0; height: max(48px, env(safe-area-inset-bottom)); pointer-events:none; background: linear-gradient(to bottom, rgba(27,31,36,0) 0%, rgba(27,31,36,0.22) 40%, rgba(27,31,36,0.32) 100%); }
        .gh-modal { background:#fff; border:1px solid #d0d7de; border-radius:14px; width: min(640px, 92vw); max-height: min(82vh, 82svh); box-shadow: 0 16px 48px rgba(140,149,159,.28), 0 1px 0 rgba(27,31,36,.06); overflow: auto; margin: calc(env(safe-area-inset-top) + clamp(16px, 8vh, 96px)) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left); }
        .gh-modal-header { display:flex; align-items:center; justify-content:space-between; padding: .85rem 1rem; border-bottom:1px solid #d0d7de; }
        .gh-modal-header h4 { margin:0; font-size:1.05rem; color:#24292f; letter-spacing:.2px; }
        .close-btn { width:28px; height:28px; display:inline-flex; align-items:center; justify-content:center; border:1px solid #d0d7de; border-radius:6px; background:#fff; color:#57606a; cursor:pointer; padding:0; }
        .close-btn:hover { background:#f6f8fa; }
        .gh-modal-body { padding: 1rem 1.1rem 1.1rem; line-height: 1.65; font-size: .96rem; color:#24292f; }
        .gh-modal-body p { margin: 0 0 .75rem; }
        .gh-modal-body ul { margin: .25rem 0 .6rem 1.2rem; padding:0; }
        .gh-modal-body li { margin: .35rem 0; }
        @media (max-width: 480px) {
            .gh-modal { width: 94vw; }
            .gh-modal-body { font-size: .98rem; }
        }
        .gh-modal-body code { 
            background:#f6f8fa; 
            border:1px solid #d0d7de; 
            border-radius:6px; 
            padding: 0 .35rem; 
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', monospace; 
            font-weight: 600; 
            color:#24292f; 
            box-shadow: inset 0 1px 0 rgba(255,255,255,.6);
        }
        /* Prevent background scroll when modal open (fallback class) */
        .no-scroll { overflow: hidden !important; }
        /* Inline validation styles */
        .input-error { border-color: #ef4444 !important; background: #fff7f7; }
        .input-valid { border-color: #22c55e !important; }
        .field-status { font-size: 0.85rem; margin-top: 0.25rem; }
        .field-status.ok { color: #16a34a; }
        .field-status.warn { color: #f59e0b; }
        .field-status.err { color: #dc2626; }
    </style>
</head>
<body>
    <h1>🔍 NanoSite SEO Generator</h1>
    <p>Generate sitemap.xml and robots.txt files for your NanoSite. This tool reads your site configuration and content to create optimized SEO files.</p>

    <div class="container">
        <div class="gh-titlebar">
            <h3 style="margin:0;">GitHub Destination</h3>
            <button id="gh-help-btn" class="info-btn" type="button" aria-label="What is this?" aria-expanded="false">?</button>
        </div>
        <div class="gh-controls">
            <div class="gh-field">
                <span class="gh-prefix">@</span>
                <input id="gh-slug" class="gh-input" placeholder="owner/repo (e.g., deemoe/NanoSite)" title="Format: owner/repo" pattern="^@?[^\/\s]+\/[^\/\s]+$">
                <button id="gh-revert" class="gh-inline-action" type="button" title="Revert from site.yaml">Revert</button>
            </div>
            <select id="gh-branch" class="gh-select" title="Select a branch" disabled>
                <option value="" selected>Loading branches…</option>
            </select>
            <div class="gh-actions" style="display:flex; align-items:center; gap:.25rem;">
                <button id="gh-save" class="btn-gh" type="button">Check</button>
            </div>
        </div>
        <div class="gh-status">
            <span id="gh-slug-status" class="badge"></span>
            <span id="gh-branch-status" class="badge"></span>
        </div>
        
    </div>

    <!-- Fullscreen help overlay -->
    <div id="gh-help-overlay" class="gh-overlay" role="dialog" aria-modal="true" aria-hidden="true">
        <div class="gh-modal" role="document">
            <div class="gh-modal-header">
                <h4>💡 What is GitHub Destination?</h4>
                <button id="gh-help-close" class="close-btn" type="button" aria-label="Close">×</button>
            </div>
            <div class="gh-modal-body">
                <p>This tells the tool which GitHub repository your site lives in.</p>
                <p><b>How to fill it in:</b></p>
                <ul>
                    <li>If your site already has this info in <code>site.yaml</code>, it will show up here automatically.</li>
                    <li>If not, just type your <code>username/repository</code> and branch name, then click <b>Save</b>.</li>
                </ul>
                <p><b>Where it’s stored:</b></p>
                <ul>
                    <li>The setting is saved only in your browser (local storage).</li>
                    <li>Nothing is uploaded anywhere until you open GitHub yourself.</li>
                </ul>
                <p><b>Why it matters:</b></p>
                <p>When you click “Open on GitHub” (to create or edit files), the tool will use this information to take you straight to the correct repository page.</p>
            </div>
        </div>
    </div>

    <div class="tabs">
        <button class="tab active" onclick="switchTab('sitemap')">Sitemap Generator</button>
        <button class="tab" onclick="switchTab('robots')">Robots.txt Generator</button>
        <button class="tab" onclick="switchTab('meta')">HTML Meta Tags</button>
        <button class="tab" onclick="switchTab('config')">Site Configuration</button>
    </div>

    <!-- Sitemap Tab -->
    <div id="sitemap-tab" class="tab-content active">
        <div class="container">
            <h2>Sitemap.xml Generator</h2>
            <div class="instructions">
                <h4>📋 Instructions:</h4>
                <ol>
                    <li>Click "Generate Sitemap" to create XML content based on your posts and tabs</li>
                    <li>Copy the generated XML content</li>
                    <li>Save it as <code>sitemap.xml</code> in your website's root directory</li>
                    <li>Make sure your robots.txt references the sitemap URL</li>
                </ol>
            </div>
            
            <div class="file-actions">
                <button class="btn-primary" onclick="generateSitemap()">Generate Sitemap</button>
                <button class="btn-secondary" onclick="copySitemap()">Copy to Clipboard</button>
                <button class="btn-secondary" onclick="downloadSitemap()">Download File</button>
                <button id="sitemap-gh-btn" class="btn-secondary" disabled title="Configure GitHub destination first">Open on GitHub</button>
            </div>
            <div id="sitemap-status"></div>
            
            <div class="output-group">
                <h3>Generated sitemap.xml:</h3>
                <textarea id="sitemapOutput" placeholder="Click 'Generate Sitemap' to create the XML content..."></textarea>
            </div>
        </div>
    </div>

    <!-- Robots.txt Tab -->
    <div id="robots-tab" class="tab-content">
        <div class="container">
            <h2>Robots.txt Generator</h2>
            <div class="instructions">
                <h4>🤖 Instructions:</h4>
                <ol>
                    <li>Click "Generate Robots.txt" to create content based on your site configuration</li>
                    <li>Copy the generated content</li>
                    <li>Save it as <code>robots.txt</code> in your website's root directory</li>
                    <li>The file includes proper sitemap references and crawling guidelines</li>
                </ol>
            </div>
            
            <div class="file-actions">
                <button class="btn-primary" onclick="generateRobots()">Generate Robots.txt</button>
                <button class="btn-secondary" onclick="copyRobots()">Copy to Clipboard</button>
                <button class="btn-secondary" onclick="downloadRobots()">Download File</button>
                <button id="robots-gh-btn" class="btn-secondary" disabled title="Configure GitHub destination first">Open on GitHub</button>
            </div>
            <div id="robots-status"></div>
            
            <div class="output-group">
                <h3>Generated robots.txt:</h3>
                <textarea id="robotsOutput" placeholder="Click 'Generate Robots.txt' to create the content..."></textarea>
            </div>
            <div class="file-actions">
                <button class="btn-secondary" onclick="openUploadAssets()">Upload images/assets on GitHub</button>
            </div>
        </div>
    </div>

    <!-- HTML Meta Tags Tab -->
    <div id="meta-tab" class="tab-content">
        <div class="container">
            <h2>HTML Meta Tags Generator</h2>
            <div class="instructions">
                <h4>🏷️ Instructions:</h4>
                <ol>
                    <li>Click "Generate Meta Tags" to create HTML meta tags based on your site configuration</li>
                    <li>Copy the generated HTML content</li>
                    <li>Replace the empty meta tags in your <code>index.html</code> file</li>
                    <li>The tags include SEO, Open Graph, and Twitter Card metadata</li>
                </ol>
            </div>
            
            <div class="file-actions">
                <button class="btn-primary" onclick="generateMetaTags()">Generate Meta Tags</button>
                <button class="btn-secondary" onclick="copyMetaTags()">Copy to Clipboard</button>
                <!-- <button class="btn-secondary" onclick="downloadMetaTags()">Download HTML</button> -->
                <button class="btn-secondary" onclick="openIndexHtmlEdit()">Open index.html on GitHub (edit)</button>
            </div>
            <div id="meta-status"></div>
            
            <div class="output-group">
                <h3>Generated HTML Meta Tags:</h3>
                <textarea id="metaOutput" placeholder="Click 'Generate Meta Tags' to create the HTML content..."></textarea>
            </div>
        </div>
    </div>

    <!-- Configuration Tab -->
    <div id="config-tab" class="tab-content">
        <div class="container">
            <h2>Site Configuration Preview</h2>
            <div class="instructions">
                <h4>⚙️ Current Configuration:</h4>
                <p>This shows your current site.yaml configuration that will be used for SEO generation.</p>
            </div>
            
            <button class="btn-primary" onclick="loadSiteConfig()">Refresh Configuration</button>
            <div id="config-status"></div>
            
            <div class="config-preview" id="configPreview">
                <h4>Loading configuration...</h4>
            </div>
            
            <div class="output-group">
                <h3>Raw site.yaml:</h3>
                <textarea id="configOutput" readonly placeholder="Click 'Refresh Configuration' to load site.yaml..."></textarea>
            </div>
        </div>
    </div>

    <script type="module">
        import { generateSitemapData } from './assets/js/seo.js';
        import { fetchConfigWithYamlFallback } from './assets/js/yaml.js';

        let currentSiteConfig = {};
        let currentPostsData = {};
        let currentTabsData = {};

        // Tab switching
        window.switchTab = function(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            
            // Show selected tab
            document.getElementById(tabName + '-tab').classList.add('active');
            event.target.classList.add('active');
        };

        async function loadSiteConfigFlex() {
            return await fetchConfigWithYamlFallback(['site.yaml', 'site.yml']);
        }

        function getContentRootFrom(cfg) {
            const raw = (cfg && (cfg.contentRoot || cfg.contentBase || cfg.contentPath)) || 'wwwroot';
            return String(raw).replace(/^\/+|\/+$/g, '');
        }

        async function loadSiteYamlRaw() {
            const attempts = ['site.yaml', 'site.yml'];
            for (const p of attempts) {
                try {
                    const r = await fetch(p);
                    if (r.ok) return await r.text();
                } catch (_) {}
            }
            return '';
        }

        // Load and preview site configuration
        window.loadSiteConfig = async function() {
            const statusEl = document.getElementById('config-status');
            const previewEl = document.getElementById('configPreview');
            const outputEl = document.getElementById('configOutput');
            
            try {
                statusEl.innerHTML = '<p>Loading configuration...</p>';
                currentSiteConfig = await loadSiteConfigFlex();
                const rawYaml = await loadSiteYamlRaw();
                outputEl.value = rawYaml || '# site.yaml not found or failed to load';
                
                // Create preview
                const getLocalizedValue = (val, fallback = 'Not set') => {
                    if (!val) return fallback;
                    if (typeof val === 'string') return val;
                    return val.default || fallback;
                };
                
                previewEl.innerHTML = `
                    <h4>Site Configuration</h4>
                    <div class="config-item"><span class="config-label">Site Title:</span> ${getLocalizedValue(currentSiteConfig.siteTitle)}</div>
                    <div class="config-item"><span class="config-label">Resource URL:</span> ${currentSiteConfig.resourceURL || 'Not set'}</div>
                    <div class="config-item"><span class="config-label">Description:</span> ${getLocalizedValue(currentSiteConfig.siteDescription)}</div>
                    <div class="config-item"><span class="config-label">Keywords:</span> ${getLocalizedValue(currentSiteConfig.siteKeywords)}</div>
                    <div class="config-item"><span class="config-label">Avatar:</span> ${currentSiteConfig.avatar || 'Not set'}</div>
                    <div class="config-item"><span class="config-label">Profile Links:</span> ${currentSiteConfig.profileLinks ? currentSiteConfig.profileLinks.length + ' links' : 'None'}</div>
                `;
                
                statusEl.innerHTML = '<p class="success">✓ Configuration loaded successfully!</p>';
                
            } catch (error) {
                console.error('Error loading site config:', error);
                statusEl.innerHTML = `<p class="error">✗ Error loading configuration: ${error.message}</p>`;
                previewEl.innerHTML = '<h4>Failed to load configuration</h4>';
            }
        };

        // Generate sitemap
        window.generateSitemap = async function() {
            const statusEl = document.getElementById('sitemap-status');
            const outputEl = document.getElementById('sitemapOutput');
            
            try {
                statusEl.innerHTML = '<p>Loading data...</p>';
                
                // Load all required data
                // Load site config to determine content root (default: wwwroot)
                currentSiteConfig = await loadSiteConfigFlex();
                const cr = getContentRootFrom(currentSiteConfig);
                const [postsObj, tabsObj] = await Promise.all([
                    fetchConfigWithYamlFallback([`${cr}/index.yaml`,`${cr}/index.yml`]),
                    fetchConfigWithYamlFallback([`${cr}/tabs.yaml`,`${cr}/tabs.yml`])
                ]);
                
                currentPostsData = postsObj || {};
                currentTabsData = tabsObj || {};
                currentSiteConfig = await loadSiteConfigFlex();
                
                // Generate sitemap data
                const urls = generateSitemapData(currentPostsData, currentTabsData, currentSiteConfig);
                
                // Generate XML
                const xml = generateSitemapXML(urls);
                
                outputEl.value = xml;
                statusEl.innerHTML = `<p class="success">✓ Sitemap generated successfully! Found ${urls.length} URLs.</p>`;
                
                // Auto-select the text for easy copying
                outputEl.select();
                
            } catch (error) {
                console.error('Error generating sitemap:', error);
                statusEl.innerHTML = `<p class="error">✗ Error generating sitemap: ${error.message}</p>`;
            }
        };

        // Generate robots.txt
        window.generateRobots = async function() {
            const statusEl = document.getElementById('robots-status');
            const outputEl = document.getElementById('robotsOutput');
            
            try {
                statusEl.innerHTML = '<p>Generating robots.txt...</p>';
                
                // Load site config if not already loaded
                if (!currentSiteConfig.resourceURL) {
                    currentSiteConfig = await loadSiteConfigFlex();
                }
                
                const robotsContent = generateRobotsTxt(currentSiteConfig);
                outputEl.value = robotsContent;
                
                statusEl.innerHTML = '<p class="success">✓ Robots.txt generated successfully!</p>';
                outputEl.select();
                
            } catch (error) {
                console.error('Error generating robots.txt:', error);
                statusEl.innerHTML = `<p class="error">✗ Error generating robots.txt: ${error.message}</p>`;
            }
        };

        // Copy functions
        window.copySitemap = function() {
            const outputEl = document.getElementById('sitemapOutput');
            outputEl.select();
            document.execCommand('copy');
            document.getElementById('sitemap-status').innerHTML = '<p class="success">✓ Sitemap copied to clipboard!</p>';
        };

        window.copyRobots = function() {
            const outputEl = document.getElementById('robotsOutput');
            outputEl.select();
            document.execCommand('copy');
            document.getElementById('robots-status').innerHTML = '<p class="success">✓ Robots.txt copied to clipboard!</p>';
        };

        // Generate HTML meta tags
        window.generateMetaTags = async function() {
            const statusEl = document.getElementById('meta-status');
            const outputEl = document.getElementById('metaOutput');
            
            try {
                statusEl.innerHTML = '<p>Generating HTML meta tags...</p>';
                
                // Load site config if not already loaded
                if (!currentSiteConfig.resourceURL) {
                    currentSiteConfig = await loadSiteConfigFlex();
                }
                
                const metaContent = generateMetaTagsHTML(currentSiteConfig);
                outputEl.value = metaContent;
                
                statusEl.innerHTML = '<p class="success">✓ HTML meta tags generated successfully!</p>';
                outputEl.select();
                
            } catch (error) {
                console.error('Error generating meta tags:', error);
                statusEl.innerHTML = `<p class="error">✗ Error generating meta tags: ${error.message}</p>`;
            }
        };

        window.copyMetaTags = function() {
            const outputEl = document.getElementById('metaOutput');
            outputEl.select();
            document.execCommand('copy');
            document.getElementById('meta-status').innerHTML = '<p class="success">✓ Meta tags copied to clipboard!</p>';
        };

        // ---- GitHub Repo config (localStorage) ----
        function parseSlug(slug) {
            const s = String(slug || '').trim();
            if (!s) return { owner: '', repo: '' };
            const cleaned = s.replace(/^@/, '');
            const parts = cleaned.split('/').filter(Boolean);
            return { owner: parts[0] || '', repo: parts[1] || '' };
        }

        function readGhRepoCfg(hydrate = true) {
            const storedSlug = localStorage.getItem('gh_slug');
            let owner = '', repo = '';
            if (storedSlug) {
                ({ owner, repo } = parseSlug(storedSlug));
            } else {
                owner = localStorage.getItem('gh_owner') || '';
                repo  = localStorage.getItem('gh_repo')  || '';
            }
            const branch = localStorage.getItem('gh_branch') || 'main';
            const $ = id => document.getElementById(id);
            const slugVal = owner && repo ? `${owner}/${repo}` : '';
            if (hydrate) {
                if ($('gh-slug')) { $('gh-slug').value = slugVal; }
                if ($('gh-branch')) { $('gh-branch').value = branch; }
            }
            return { owner, repo, branch };
        }
        function getGhCfgFromUIOrStorage() {
            const slugEl = document.getElementById('gh-slug');
            const branchEl = document.getElementById('gh-branch');
            let owner = '', repo = '', branch = '';
            if (slugEl && slugEl.value) { ({ owner, repo } = parseSlug(slugEl.value)); }
            if (branchEl && branchEl.value) branch = branchEl.value;
            const stored = readGhRepoCfg(false);
            if (!owner || !repo) { owner = stored.owner; repo = stored.repo; }
            if (!branch) { branch = stored.branch; }
            return { owner, repo, branch };
        }
        window.saveGhRepoCfg = function () {
            const $ = id => document.getElementById(id);
            const { owner, repo } = parseSlug($('gh-slug')?.value || '');
            const branch = ($('gh-branch')?.value || '').trim();
            if (!owner || !repo) {
                alert('Please enter a repository as owner/repo');
                return;
            }
            if (!branch) {
                alert('Please select a branch');
                return;
            }
            const slug = `${owner}/${repo}`;
            localStorage.setItem('gh_slug', slug);
            // Keep backward-compatible keys
            localStorage.setItem('gh_owner', owner);
            localStorage.setItem('gh_repo', repo);
            localStorage.setItem('gh_branch', branch);
            // Reflect formatted value back to input
            if ($('gh-slug')) $('gh-slug').value = slug;
            alert('Saved.');
        };
        readGhRepoCfg();

        // Try to infer GitHub repo from site.yaml (reportIssueURL/profileLinks)
        async function autoFillGhRepoCfgFromSiteYaml() {
            // Respect existing local settings
            const hasLocal = (localStorage.getItem('gh_slug') || localStorage.getItem('gh_owner') || localStorage.getItem('gh_repo'));
            if (hasLocal) return;
            try {
                const cfg = await loadSiteConfigFlex();
                const inferred = getGhConfigFromSiteYaml(cfg);
                if (inferred && inferred.owner && inferred.repo) {
                    const slug = `${inferred.owner}/${inferred.repo}`;
                    localStorage.setItem('gh_slug', slug);
                    localStorage.setItem('gh_owner', inferred.owner);
                    localStorage.setItem('gh_repo', inferred.repo);
                    if (inferred.branch) localStorage.setItem('gh_branch', inferred.branch);
                    // Reflect into UI if present
                    const $ = id => document.getElementById(id);
                    if ($('gh-slug')) $('gh-slug').value = slug;
                    if ($('gh-branch') && inferred.branch) $('gh-branch').value = inferred.branch;
                }
            } catch (_) { /* noop */ }
        }

        function getGhConfigFromSiteYaml(cfg = {}) {
            // 1) Explicit fields if present (optional convention)
            //    e.g. github: { owner: "deemoe404", repo: "NanoSite", branch: "main" }
            if (cfg.github && (cfg.github.owner || cfg.github.repo)) {
                return {
                    owner: (cfg.github.owner || '').trim(),
                    repo: (cfg.github.repo || '').trim(),
                    branch: (cfg.github.branch || 'main').trim()
                };
            }
            // 2) From reportIssueURL
            if (cfg.reportIssueURL && typeof cfg.reportIssueURL === 'string') {
                const m = cfg.reportIssueURL.match(/https:\/\/github\.com\/([^\/]+)\/([^\/?#]+)/i);
                if (m) return { owner: m[1], repo: m[2], branch: 'main' };
            }
            // 3) From profileLinks array
            if (Array.isArray(cfg.profileLinks)) {
                for (const link of cfg.profileLinks) {
                    const href = link && link.href;
                    if (typeof href === 'string') {
                        const m = href.match(/https:\/\/github\.com\/([^\/]+)\/([^\/?#]+)/i);
                        if (m) return { owner: m[1], repo: m[2], branch: 'main' };
                    }
                }
            }
            return null;
        }

        // Kick off auto-fill (best-effort)
        autoFillGhRepoCfgFromSiteYaml();

        // ---- Inline validation and GitHub lookup ----
        function setFieldStatus(id, type, text, withSpinner = false) {
            const el = document.getElementById(id);
            if (!el) return;
            el.classList.remove('ok','warn','err');
            if (type) el.classList.add(type);
            if (withSpinner) {
                el.innerHTML = `<span class="spinner"></span><span>${text || ''}</span>`;
            } else {
                el.textContent = text || '';
            }
        }

        function setInputState(input, state) {
            if (!input) return;
            input.classList.remove('input-error','input-valid');
            const wrap = input.closest('.gh-field');
            if (wrap) wrap.classList.remove('error','valid');
            if (state === 'error') {
                input.classList.add('input-error');
                if (wrap) wrap.classList.add('error');
            }
            if (state === 'valid') {
                input.classList.add('input-valid');
                if (wrap) wrap.classList.add('valid');
            }
        }

        function debounce(fn, delay = 400) {
            let t = null;
            return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), delay); };
        }

        let repoIsValid = false;
        function setSaveMode(mode) {
            const btn = document.getElementById('gh-save');
            if (!btn) return;
            if (mode === 'save') {
                btn.innerHTML = 'Save';
                btn.disabled = false;
                btn.onclick = saveGhRepoCfg;
            } else if (mode === 'checking') {
                btn.innerHTML = '<span class="spinner"></span><span>Checking…</span>';
                btn.disabled = true;
                btn.onclick = null;
            } else { // 'check'
                btn.innerHTML = 'Check';
                btn.disabled = false;
                btn.onclick = (e) => { e.preventDefault(); validateSlugAndLoadBranches(); };
            }
        }

        function updateSaveEnabled() {
            const branchEl = document.getElementById('gh-branch');
            const ok = repoIsValid && !!(branchEl && branchEl.value);
            setSaveMode(ok ? 'save' : 'check');
        }

        async function fetchRepoInfo(owner, repo) {
            try {
                const r = await fetch(`https://api.github.com/repos/${owner}/${repo}`, { headers: { 'Accept': 'application/vnd.github+json' } });
                if (r.status === 404) return { exists: false };
                if (r.status === 403) return { exists: false, error: 'GitHub rate limit hit. Try again later.' };
                if (!r.ok) return { exists: false, error: `GitHub API error: ${r.status}` };
                const data = await r.json();
                return { exists: true, default_branch: data.default_branch || 'main' };
            } catch (e) {
                return { exists: false, error: e.message };
            }
        }

        async function fetchBranches(owner, repo, limitPages = 2) {
            const branches = [];
            const per = 100;
            for (let page = 1; page <= limitPages; page++) {
                const url = `https://api.github.com/repos/${owner}/${repo}/branches?per_page=${per}&page=${page}`;
                const r = await fetch(url, { headers: { 'Accept': 'application/vnd.github+json' } });
                if (!r.ok) break;
                const arr = await r.json();
                if (!Array.isArray(arr) || arr.length === 0) break;
                for (const b of arr) { if (b && b.name) branches.push(b.name); }
                if (arr.length < per) break;
            }
            return branches;
        }

        function populateBranchSuggestions(branches, preferred) {
            const select = document.getElementById('gh-branch');
            if (!select) return;
            select.innerHTML = '';
            const unique = Array.from(new Set(branches || []));
            if (unique.length === 0) {
                const opt = document.createElement('option');
                opt.value = '';
                opt.textContent = 'No branches found';
                select.appendChild(opt);
                select.disabled = true;
                return;
            }
            for (const name of unique) {
                const opt = document.createElement('option');
                opt.value = name;
                opt.textContent = name;
                select.appendChild(opt);
            }
            select.disabled = false;
            if (preferred) select.value = preferred;
        }

        async function validateSlugAndLoadBranches() {
            const slugEl = document.getElementById('gh-slug');
            const branchEl = document.getElementById('gh-branch');
            if (!slugEl) return;
            const { owner, repo } = parseSlug(slugEl.value);
            if (!owner || !repo) {
                setInputState(slugEl, slugEl.value.trim() ? 'error' : null);
                setFieldStatus('gh-slug-status', slugEl.value.trim() ? 'err' : null, slugEl.value.trim() ? 'Format must be owner/repo' : '');
                repoIsValid = false;
                updateSaveEnabled();
                return;
            }
            setFieldStatus('gh-slug-status', 'warn', 'Checking repository…', true);
            setInputState(slugEl, null);
            setSaveMode('checking');
            // Disable branch select while checking
            if (branchEl) { branchEl.disabled = true; }
            setFieldStatus('gh-branch-status', null, '');
            const info = await fetchRepoInfo(owner, repo);
            if (!info.exists) {
                setInputState(slugEl, 'error');
                setFieldStatus('gh-slug-status', 'err', info.error ? String(info.error) : 'Repository not found on GitHub');
                repoIsValid = false;
                updateSaveEnabled();
                return;
            }
            setInputState(slugEl, 'valid');
            setFieldStatus('gh-slug-status', 'ok', `Found @${owner}/${repo}`);
            setFieldStatus('gh-branch-status', 'warn', 'Loading branches…', true);
            try {
                const branches = await fetchBranches(owner, repo);
                populateBranchSuggestions(branches, (branchEl && branchEl.value) ? branchEl.value : (localStorage.getItem('gh_branch') || info.default_branch));
                setFieldStatus('gh-branch-status', 'ok', `${branches.length} branches`);
                repoIsValid = true;
                updateSaveEnabled();
                updateGhActionButtons();
            } catch (e) {
                setFieldStatus('gh-branch-status', 'err', `Failed to load branches: ${e.message}`);
                repoIsValid = false;
                updateSaveEnabled();
            }
        }

        // Attach listeners
        const slugInput = document.getElementById('gh-slug');
        const branchInput = document.getElementById('gh-branch');
        const saveBtn = document.getElementById('gh-save');
        if (slugInput) {
            // While typing: no network calls, hide badges, switch button to Check
            slugInput.addEventListener('input', () => {
                // Always hide both badges on edit
                setFieldStatus('gh-slug-status', null, '');
                setFieldStatus('gh-branch-status', null, '');
                // Clear and disable branch select
                if (branchInput) { branchInput.disabled = true; branchInput.value = ''; branchInput.innerHTML = '<option value="" selected>Loading branches…</option>'; }
                // Neutralize input state while typing (no red border spam)
                setInputState(slugInput, null);
                // Force button to Check mode until next validation
                repoIsValid = false;
                updateSaveEnabled();
            });
            // Enter triggers validation (no page refresh)
            slugInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') { e.preventDefault(); slugInput.blur(); validateSlugAndLoadBranches(); }
            });
            // Do the GitHub checks only on blur
            slugInput.addEventListener('blur', validateSlugAndLoadBranches);
        }
        if (branchInput) {
            branchInput.addEventListener('change', () => { updateSaveEnabled(); updateGhActionButtons(); });
        }
        if (saveBtn) {
            setSaveMode('check'); // default until validated
        }

        // Help overlay toggle
        (function initHelpOverlay(){
            const btn = document.getElementById('gh-help-btn');
            const overlay = document.getElementById('gh-help-overlay');
            const closeBtn = document.getElementById('gh-help-close');
            if (!btn || !overlay || !closeBtn) return;
            // Visual viewport height var to stabilize iOS centering
            function setVvh(){
                document.documentElement.style.setProperty('--vvh', `${window.innerHeight}px`);
            }
            setVvh();
            window.addEventListener('resize', setVvh, { passive: true });
            let scrollY = 0;
            function close(){ 
                overlay.classList.remove('open'); 
                overlay.setAttribute('aria-hidden','true'); 
                btn.setAttribute('aria-expanded','false'); 
                // Restore scroll position (iOS-safe)
                document.body.style.position = '';
                document.body.style.top = '';
                document.body.style.left = '';
                document.body.style.right = '';
                document.body.style.width = '';
                window.scrollTo(0, scrollY);
            }
            function open(){ 
                // Lock scroll (iOS-friendly): fix body and offset by current scrollY
                scrollY = window.scrollY || window.pageYOffset || 0;
                document.body.style.position = 'fixed';
                document.body.style.top = `-${scrollY}px`;
                document.body.style.left = '0';
                document.body.style.right = '0';
                document.body.style.width = '100%';
                overlay.classList.add('open'); 
                overlay.setAttribute('aria-hidden','false'); 
                btn.setAttribute('aria-expanded','true'); 
            }
            btn.addEventListener('click', (e)=>{ e.stopPropagation(); if(overlay.classList.contains('open')) close(); else open(); });
            closeBtn.addEventListener('click', (e)=>{ e.stopPropagation(); close(); });
            overlay.addEventListener('click', close);
            overlay.querySelector('.gh-modal').addEventListener('click', (e)=> e.stopPropagation());
            document.addEventListener('keydown', (e)=>{ if(e.key==='Escape') close(); });
        })();

        // Revert from site.yaml
        (function initRevertFromSiteYaml(){
            const btn = document.getElementById('gh-revert');
            if (!btn) return;
            btn.addEventListener('click', async (e) => {
                e.preventDefault();
                const slugEl = document.getElementById('gh-slug');
                const branchEl = document.getElementById('gh-branch');
                // Clear status
                setFieldStatus('gh-slug-status', null, '');
                setFieldStatus('gh-branch-status', null, '');
                try {
                    const cfg = await loadSiteConfigFlex();
                    const inferred = getGhConfigFromSiteYaml(cfg);
                    if (!inferred || !inferred.owner || !inferred.repo) {
                        setFieldStatus('gh-slug-status', 'err', 'No GitHub repository found in site.yaml');
                        return;
                    }
                    if (slugEl) slugEl.value = `${inferred.owner}/${inferred.repo}`;
                    if (branchEl) { branchEl.value = (inferred.branch || 'main'); branchEl.disabled = true; branchEl.innerHTML = '<option value="" selected>Loading branches…</option>'; }
                    // Trigger validation + branch loading based on new values
                    await validateSlugAndLoadBranches();
                    // Auto-save after successful validation and branch resolution
                    if (slugEl && slugEl.value && branchEl && branchEl.value) {
                        saveGhRepoCfg();
                    }
                } catch (err) {
                    setFieldStatus('gh-slug-status', 'err', 'Failed to read site.yaml');
                }
            });
        })();

        // Initial validation/population if we already have a slug
        // Initial check (if slug already present), but not while typing
        validateSlugAndLoadBranches();

        // ---- GitHub URL helpers (no token needed) ----
        function ghEditUrl({owner, repo, branch}, path) {
            return `https://github.com/${owner}/${repo}/edit/${encodeURIComponent(branch)}/${path.replace(/^\/+/, '')}`;
        }
        function ghNewUrl({owner, repo, branch}, dir, filename, value) {
            const qs = new URLSearchParams({ filename, value });
            return `https://github.com/${owner}/${repo}/new/${encodeURIComponent(branch)}/${dir.replace(/^\/+/, '')}?${qs.toString()}`;
        }
        function ghUploadUrl({owner, repo, branch}, dir) {
            return `https://github.com/${owner}/${repo}/upload/${encodeURIComponent(branch)}/${dir.replace(/^\/+/, '')}`;
        }
        function openUrl(u){ window.open(u, '_blank', 'noopener'); }

        // To avoid overly long URLs: switch to new-file page and manual paste when content is large
        function safeOpenNewWithContent(cfg, dir, filename, content) {
            const urlLenBudget = 7000; // Practical limit to avoid truncation
            if (encodeURIComponent(content).length + filename.length + dir.length < urlLenBudget) {
                openUrl(ghNewUrl(cfg, dir, filename, content));
            } else {
                alert('Content is long. Opened a new-file page; please paste the content in the GitHub editor and commit.');
                openUrl(ghNewUrl(cfg, dir, filename, ''));
            }
        }

        // Sitemap new/edit
        window.openSitemapNew = function() {
            const cfg = getGhCfgFromUIOrStorage();
            const content = document.getElementById('sitemapOutput').value || '';
            if (!cfg.owner || !cfg.repo) return alert('Please fill owner/repo/branch first');
            safeOpenNewWithContent(cfg, '', 'sitemap.xml', content);
        };
        window.openSitemapEdit = function() {
            const cfg = getGhCfgFromUIOrStorage();
            if (!cfg.owner || !cfg.repo) return alert('Please fill owner/repo/branch first');
            openUrl(ghEditUrl(cfg, 'sitemap.xml'));
        };

        // Robots new/edit
        window.openRobotsNew = function() {
            const cfg = getGhCfgFromUIOrStorage();
            const content = document.getElementById('robotsOutput').value || '';
            if (!cfg.owner || !cfg.repo) return alert('Please fill owner/repo/branch first');
            safeOpenNewWithContent(cfg, '', 'robots.txt', content);
        };
        window.openRobotsEdit = function() {
            const cfg = getGhCfgFromUIOrStorage();
            if (!cfg.owner || !cfg.repo) return alert('Please fill owner/repo/branch first');
            openUrl(ghEditUrl(cfg, 'robots.txt'));
        };

        // Meta: open index.html for manual paste
        window.openIndexHtmlEdit = function() {
            const cfg = getGhCfgFromUIOrStorage();
            if (!cfg.owner || !cfg.repo) return alert('Please fill owner/repo/branch first');
            openUrl(ghEditUrl(cfg, 'index.html'));
        };

        // Optional: upload images/assets shortcut
        window.openUploadAssets = function() {
            const cfg = getGhCfgFromUIOrStorage();
            if (!cfg.owner || !cfg.repo) return alert('Please fill owner/repo/branch first');
            openUrl(ghUploadUrl(cfg, 'assets'));
        };

        // ---- GitHub file existence checks -> update action buttons ----
        async function ghFileExists({owner, repo, branch}, path) {
            try {
                const url = `https://api.github.com/repos/${owner}/${repo}/contents/${path.replace(/^\/+/, '')}?ref=${encodeURIComponent(branch)}`;
                const r = await fetch(url, { headers: { 'Accept': 'application/vnd.github+json' } });
                if (r.status === 404) return false;
                return r.ok;
            } catch (_) {
                return false;
            }
        }

        function setGhBtnState(btn, exists, path, onNew, onEdit) {
            if (!btn) return;
            btn.disabled = false;
            if (exists) {
                btn.textContent = `Edit on GitHub`;
                btn.onclick = onEdit;
                btn.title = `Edit ${path} on GitHub`;
                btn.setAttribute('aria-label', `Edit ${path} on GitHub`);
            } else {
                btn.textContent = 'Create on GitHub';
                btn.onclick = onNew;
                btn.title = `Create ${path} on GitHub`;
                btn.setAttribute('aria-label', `Create ${path} on GitHub`);
            }
        }

        async function updateGhActionButtons() {
            const cfg = getGhCfgFromUIOrStorage();
            const sitemapBtn = document.getElementById('sitemap-gh-btn');
            const robotsBtn = document.getElementById('robots-gh-btn');
            const hasCfg = !!(cfg.owner && cfg.repo && cfg.branch);
            if (sitemapBtn) sitemapBtn.disabled = !hasCfg;
            if (robotsBtn) robotsBtn.disabled = !hasCfg;
            if (!hasCfg) return;
            try {
                const [siteExists, robotsExists] = await Promise.all([
                    ghFileExists(cfg, 'sitemap.xml'),
                    ghFileExists(cfg, 'robots.txt')
                ]);
                setGhBtnState(sitemapBtn, siteExists, 'sitemap.xml', window.openSitemapNew, window.openSitemapEdit);
                setGhBtnState(robotsBtn, robotsExists, 'robots.txt', window.openRobotsNew, window.openRobotsEdit);
            } catch (_) {
                // On error, leave buttons enabled but default to "new"
                if (sitemapBtn) setGhBtnState(sitemapBtn, false, 'sitemap.xml', window.openSitemapNew, window.openSitemapEdit);
                if (robotsBtn) setGhBtnState(robotsBtn, false, 'robots.txt', window.openRobotsNew, window.openRobotsEdit);
            }
        }

        // Download functions
        window.downloadSitemap = function() {
            const content = document.getElementById('sitemapOutput').value;
            downloadFile('sitemap.xml', content, 'application/xml');
        };

        window.downloadRobots = function() {
            const content = document.getElementById('robotsOutput').value;
            downloadFile('robots.txt', content, 'text/plain');
        };

        window.downloadMetaTags = function() {
            const content = document.getElementById('metaOutput').value;
            downloadFile('meta-tags.html', content, 'text/html');
        };

        function downloadFile(filename, content, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function generateSitemapXML(urls) {
            let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
            xml += '<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">\n';
            
            urls.forEach(url => {
                xml += '  <url>\n';
                xml += `    <loc>${escapeXML(url.loc)}</loc>\n`;
                xml += `    <lastmod>${url.lastmod}</lastmod>\n`;
                xml += `    <changefreq>${url.changefreq}</changefreq>\n`;
                xml += `    <priority>${url.priority}</priority>\n`;
                xml += '  </url>\n';
            });
            
            xml += '</urlset>';
            return xml;
        }

        function generateRobotsTxt(siteConfig) {
            // Use site's base URL (remove current file path)
            const baseUrl = window.location.origin + '/';
            const cr = getContentRootFrom(siteConfig);
            
            let robots = `User-agent: *\n`;
            robots += `Allow: /\n\n`;
            
            robots += `# Sitemap\n`;
            robots += `Sitemap: ${baseUrl}sitemap.xml\n\n`;
            
            robots += `# Allow crawling of main content\n`;
            robots += `Allow: /${cr}/\n`;
            robots += `Allow: /assets/\n\n`;
            
            robots += `# Disallow admin or internal directories\n`;
            robots += `Disallow: /admin/\n`;
            robots += `Disallow: /.git/\n`;
            robots += `Disallow: /node_modules/\n`;
            robots += `Disallow: /.env\n`;
            robots += `Disallow: /package.json\n`;
            robots += `Disallow: /package-lock.json\n\n`;
            
            robots += `# SEO tools (allow but not priority)\n`;
            robots += `Allow: /seo-generator.html\n`;
            robots += `Allow: /sitemap-generator.html\n\n`;
            
            robots += `# Crawl delay (be nice to servers)\n`;
            robots += `Crawl-delay: 1\n\n`;
            
            robots += `# Generated by NanoSite SEO Generator\n`;
            robots += `# ${new Date().toISOString()}\n`;
            
            return robots;
        }

        function generateMetaTagsHTML(siteConfig) {
            // Use site's base URL
            const baseUrl = window.location.origin + '/';
            
            // Helper to get localized value with fallback
            const getLocalizedValue = (val, fallback = '') => {
                if (!val) return fallback;
                if (typeof val === 'string') return val;
                return val.default || fallback;
            };
            
            // Extract values from site config
            const siteTitle = getLocalizedValue(siteConfig.siteTitle, 'NanoSite');
            const siteDescription = getLocalizedValue(siteConfig.siteDescription, 'A pure front-end blog template');
            const siteKeywords = getLocalizedValue(siteConfig.siteKeywords, 'blog, static site, markdown');
            const avatar = siteConfig.avatar || 'assets/avatar.png';
            const fullAvatarUrl = avatar.startsWith('http') ? avatar : baseUrl + avatar;
            
            let html = `  <!-- Primary SEO Meta Tags -->\n`;
            html += `  <title>${escapeHTML(siteTitle)}</title>\n`;
            html += `  <meta name="title" content="${escapeHTML(siteTitle)}">\n`;
            html += `  <meta name="description" content="${escapeHTML(siteDescription)}">\n`;
            html += `  <meta name="keywords" content="${escapeHTML(siteKeywords)}">\n`;
            html += `  <meta name="author" content="${escapeHTML(siteTitle)}">\n`;
            html += `  <meta name="robots" content="index, follow">\n`;
            html += `  <link rel="canonical" href="${baseUrl}">\n`;
            html += `  \n`;
            html += `  <!-- Open Graph / Facebook -->\n`;
            html += `  <meta property="og:type" content="website">\n`;
            html += `  <meta property="og:url" content="${baseUrl}">\n`;
            html += `  <meta property="og:title" content="${escapeHTML(siteTitle)}">\n`;
            html += `  <meta property="og:description" content="${escapeHTML(siteDescription)}">\n`;
            html += `  <meta property="og:image" content="${fullAvatarUrl}">\n`;
            html += `  <meta property="og:logo" content="${fullAvatarUrl}">\n`;
            html += `  \n`;
            html += `  <!-- Twitter -->\n`;
            html += `  <meta property="twitter:card" content="summary_large_image">\n`;
            html += `  <meta property="twitter:url" content="${baseUrl}">\n`;
            html += `  <meta property="twitter:title" content="${escapeHTML(siteTitle)}">\n`;
            html += `  <meta property="twitter:description" content="${escapeHTML(siteDescription)}">\n`;
            html += `  <meta property="twitter:image" content="${fullAvatarUrl}">\n`;
            html += `  \n`;
            html += `  <!-- Initial meta tags - will be updated by dynamic SEO system -->\n`;
            html += `  <meta name="theme-color" content="#1a1a1a">\n`;
            html += `  <meta name="msapplication-TileColor" content="#1a1a1a">\n`;
            html += `  <link rel="icon" type="image/png" href="${avatar}">`;
            
            return html;
        }

        function escapeHTML(str) {
            return String(str || '').replace(/[&<>"']/g, function(char) {
                switch (char) {
                    case '&': return '&amp;';
                    case '<': return '&lt;';
                    case '>': return '&gt;';
                    case '"': return '&quot;';
                    case "'": return '&#39;';
                    default: return char;
                }
            });
        }

        function escapeXML(str) {
            return str.replace(/[<>&'"]/g, function(char) {
                switch (char) {
                    case '<': return '&lt;';
                    case '>': return '&gt;';
                    case '&': return '&amp;';
                    case "'": return '&apos;';
                    case '"': return '&quot;';
                    default: return char;
                }
            });
        }

        // Load site config on page load
        loadSiteConfig();
    </script>
</body>
</html>
