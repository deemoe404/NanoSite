import { state } from './seo-tool-state.js';
import { initSyntaxHighlighting } from './syntax-highlight.js';
import { setEditorValue, getEditorValue } from './hieditor.js';
import { generateSitemapData } from './seo.js';
import { fetchConfigWithYamlFallback } from './yaml.js';
import { getContentRootFrom, loadSiteConfigFlex } from './seo-tool-config.js';

function t(kind, msg){ try { window.showToast && window.showToast(kind, msg); } catch (_) {} }

// Formatters
function formatXML(xml) {
  try {
    const P = />(\s*)</g;
    xml = xml.replace(P, '>$1\n<');
    let pad = 0; let result = '';
    xml.split('\n').forEach(line => {
      if (!line.trim()) return;
      if (line.match(/^<\//)) pad = Math.max(pad - 1, 0);
      result += '  '.repeat(pad) + line.trim() + '\n';
      if (line.match(/^<[^!?][^>]*[^\/]>/) && !line.match(/<.*<\/.*>/)) pad += 1;
    });
    return result.trim();
  } catch (_) { return xml; }
}
function formatHTMLFragment(html) { return formatXML(html); }

// Escapers
function escapeHTML(str) {
  return String(str || '').replace(/[&<>"']/g, function(char) {
    switch (char) {
      case '&': return '&amp;';
      case '<': return '&lt;';
      case '>': return '&gt;';
      case '"': return '&quot;';
      case "'": return '&#39;';
      default: return char;
    }
  });
}
function escapeXML(str) {
  return String(str || '').replace(/[<>&'\"]/g, function(char) {
    switch (char) {
      case '<': return '&lt;';
      case '>': return '&gt;';
      case '&': return '&amp;';
      case "'": return '&apos;';
      case '"': return '&quot;';
      default: return char;
    }
  });
}

// Generators
function generateSitemapXML(urls) {
  let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
  xml += '<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">\n';
  urls.forEach(url => {
    xml += '  <url>\n';
    xml += `    <loc>${escapeXML(url.loc)}</loc>\n`;
    xml += `    <lastmod>${url.lastmod}</lastmod>\n`;
    xml += `    <changefreq>${url.changefreq}</changefreq>\n`;
    xml += `    <priority>${url.priority}</priority>\n`;
    xml += '  </url>\n';
  });
  xml += '</urlset>';
  return xml;
}

function generateRobotsTxt(siteConfig) {
  const baseUrl = window.location.origin + '/';
  const cr = getContentRootFrom(siteConfig);
  let robots = `User-agent: *\n`;
  robots += `Allow: /\n\n`;
  robots += `# Sitemap\n`;
  robots += `Sitemap: ${baseUrl}sitemap.xml\n\n`;
  robots += `# Allow crawling of main content\n`;
  robots += `Allow: /${cr}/\n`;
  robots += `Allow: /assets/\n\n`;
  robots += `# Disallow admin or internal directories\n`;
  robots += `Disallow: /admin/\n`;
  robots += `Disallow: /.git/\n`;
  robots += `Disallow: /node_modules/\n`;
  robots += `Disallow: /.env\n`;
  robots += `Disallow: /package.json\n`;
  robots += `Disallow: /package-lock.json\n\n`;
  robots += `# SEO tools (allow but not priority)\n`;
  robots += `Allow: /seo-generator.html\n`;
  robots += `Allow: /sitemap-generator.html\n\n`;
  robots += `# Crawl delay (be nice to servers)\n`;
  robots += `Crawl-delay: 1\n\n`;
  robots += `# Generated by NanoSite SEO Generator\n`;
  robots += `# ${new Date().toISOString()}\n`;
  return robots;
}

function generateMetaTagsHTML(siteConfig) {
  const baseUrl = window.location.origin + '/';
  const getLocalizedValue = (val, fallback = '') => {
    if (!val) return fallback;
    if (typeof val === 'string') return val;
    return val.default || fallback;
  };
  const siteTitle = getLocalizedValue(siteConfig.siteTitle, 'NanoSite');
  const siteDescription = getLocalizedValue(siteConfig.siteDescription, 'A pure front-end blog template');
  const siteKeywords = getLocalizedValue(siteConfig.siteKeywords, 'blog, static site, markdown');
  const avatar = siteConfig.avatar || 'assets/avatar.png';
  const fullAvatarUrl = avatar.startsWith('http') ? avatar : baseUrl + avatar;
  let html = `  <!-- Primary SEO Meta Tags -->\n`;
  html += `  <title>${escapeHTML(siteTitle)}</title>\n`;
  html += `  <meta name="title" content="${escapeHTML(siteTitle)}">\n`;
  html += `  <meta name="description" content="${escapeHTML(siteDescription)}">\n`;
  html += `  <meta name="keywords" content="${escapeHTML(siteKeywords)}">\n`;
  html += `  <meta name="author" content="${escapeHTML(siteTitle)}">\n`;
  html += `  <meta name="robots" content="index, follow">\n`;
  html += `  <link rel="canonical" href="${baseUrl}">\n`;
  html += `  \n`;
  html += `  <!-- Open Graph / Facebook -->\n`;
  html += `  <meta property="og:type" content="website">\n`;
  html += `  <meta property="og:url" content="${baseUrl}">\n`;
  html += `  <meta property="og:title" content="${escapeHTML(siteTitle)}">\n`;
  html += `  <meta property="og:description" content="${escapeHTML(siteDescription)}">\n`;
  html += `  <meta property="og:image" content="${fullAvatarUrl}">\n`;
  html += `  <meta property="og:logo" content="${fullAvatarUrl}">\n`;
  html += `  \n`;
  html += `  <!-- Twitter -->\n`;
  html += `  <meta property="twitter:card" content="summary_large_image">\n`;
  html += `  <meta property="twitter:url" content="${baseUrl}">\n`;
  html += `  <meta property="twitter:title" content="${escapeHTML(siteTitle)}">\n`;
  html += `  <meta property="twitter:description" content="${escapeHTML(siteDescription)}">\n`;
  html += `  <meta property="twitter:image" content="${fullAvatarUrl}">\n`;
  html += `  \n`;
  html += `  <!-- Initial meta tags - will be updated by dynamic SEO system -->\n`;
  html += `  <meta name="theme-color" content="#1a1a1a">\n`;
  html += `  <meta name="msapplication-TileColor" content="#1a1a1a">\n`;
  html += `  <link rel="icon" type="image/png" href="${avatar}">`;
  return html;
}

// --- Code preview helper ---
function updateCodePreview(previewId, content, language) {
  try {
    const pre = document.getElementById(previewId);
    if (!pre) return;
    // Ensure structure contains a code element
    let code = pre.querySelector('code');
    if (!code) {
      code = document.createElement('code');
      pre.innerHTML = '';
      pre.appendChild(code);
    }
    // Assign explicit language class for highlighter
    const langClass = `language-${(language || 'plain').toLowerCase()}`;
    // Reset existing language-* classes
    Array.from(code.classList).forEach(c => { if (c.startsWith('language-')) code.classList.remove(c); });
    code.classList.add(langClass);
    // Set raw text (clears previous markup if any)
    code.textContent = content || '';
    // Apply highlighter/line numbers
    try { initSyntaxHighlighting(); } catch (_) {}
  } catch (_) {}
}

// Public API for onclick bindings
async function generateSitemap() {
  const statusEl = document.getElementById('sitemap-status');
  const outputEl = document.getElementById('sitemapOutput');
  try {
    if (statusEl) statusEl.innerHTML = '<p>Loading data...</p>';
    state.currentSiteConfig = await loadSiteConfigFlex();
    const cr = getContentRootFrom(state.currentSiteConfig);
    const [postsObj, tabsObj] = await Promise.all([
      fetchConfigWithYamlFallback([`${cr}/index.yaml`,`${cr}/index.yml`]),
      fetchConfigWithYamlFallback([`${cr}/tabs.yaml`,`${cr}/tabs.yml`])
    ]);
    state.currentPostsData = postsObj || {};
    state.currentTabsData = tabsObj || {};
    state.currentSiteConfig = await loadSiteConfigFlex();
    const urls = generateSitemapData(state.currentPostsData, state.currentTabsData, state.currentSiteConfig);
    const xml = generateSitemapXML(urls);
    if (outputEl) outputEl.value = xml;
    try { setEditorValue('sitemapOutput', xml); } catch (_) {}
    if (statusEl) statusEl.innerHTML = `<p class="success">✓ Sitemap generated successfully! Found ${urls.length} URLs.</p>`;
    t('ok', `Sitemap generated (${urls.length} URLs)`);
    outputEl && outputEl.select();
  } catch (error) {
    console.error('Error generating sitemap:', error);
    if (statusEl) statusEl.innerHTML = `<p class="error">✗ Error generating sitemap: ${error.message}</p>`;
    t('err', `Sitemap error: ${error.message}`);
  }
}

async function generateRobots() {
  const statusEl = document.getElementById('robots-status');
  const outputEl = document.getElementById('robotsOutput');
  try {
    if (statusEl) statusEl.innerHTML = '<p>Generating robots.txt...</p>';
    if (!state.currentSiteConfig.resourceURL) state.currentSiteConfig = await loadSiteConfigFlex();
    const robotsContent = generateRobotsTxt(state.currentSiteConfig);
    if (outputEl) outputEl.value = robotsContent;
    try { setEditorValue('robotsOutput', robotsContent); } catch (_) {}
    if (statusEl) statusEl.innerHTML = '<p class="success">✓ Robots.txt generated successfully!</p>';
    outputEl && outputEl.select();
    t('ok', 'Robots.txt generated');
  } catch (error) {
    console.error('Error generating robots.txt:', error);
    if (statusEl) statusEl.innerHTML = `<p class="error">✗ Error generating robots.txt: ${error.message}</p>`;
    t('err', `Robots error: ${error.message}`);
  }
}

async function generateMetaTags() {
  const statusEl = document.getElementById('meta-status');
  const outputEl = document.getElementById('metaOutput');
  try {
    if (statusEl) statusEl.innerHTML = '<p>Generating HTML meta tags...</p>';
    if (!state.currentSiteConfig.resourceURL) state.currentSiteConfig = await loadSiteConfigFlex();
    const metaContent = generateMetaTagsHTML(state.currentSiteConfig);
    if (outputEl) outputEl.value = metaContent;
    try { setEditorValue('metaOutput', metaContent); } catch (_) {}
    if (statusEl) statusEl.innerHTML = '<p class="success">✓ HTML meta tags generated successfully!</p>';
    outputEl && outputEl.select();
    t('ok', 'Meta tags generated');
  } catch (error) {
    console.error('Error generating meta tags:', error);
    if (statusEl) statusEl.innerHTML = `<p class="error">✗ Error generating meta tags: ${error.message}</p>`;
  }
}

function copyFromTextarea(id, okMsg){
  let val = '';
  try { val = getEditorValue(id) || ''; } catch (_) {}
  if (!val) {
    const el = document.getElementById(id);
    val = el ? (el.value || '') : '';
  }
  if (!val) return;
  if (navigator.clipboard && navigator.clipboard.writeText) {
    navigator.clipboard.writeText(val)
      .then(()=>{ t('ok', okMsg); })
      .catch(()=>{ el.select(); document.execCommand('copy'); t('ok', okMsg); });
  } else { el.select(); document.execCommand('copy'); t('ok', okMsg); }
}

function downloadFile(filename, content, mimeType) {
  const blob = new Blob([content], { type: mimeType });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = filename; document.body.appendChild(a); a.click();
  document.body.removeChild(a); URL.revokeObjectURL(url);
}

// Validators
function validateSitemap(){
  const val = getEditorValue('sitemapOutput') || (document.getElementById('sitemapOutput') || {}).value || '';
  try {
    const parser = new DOMParser();
    const doc = parser.parseFromString(val, 'application/xml');
    const err = doc.getElementsByTagName('parsererror')[0];
    if (err) { t('err', 'Invalid XML'); return false; }
    const ok = doc.documentElement && (doc.documentElement.localName === 'urlset');
    t(ok ? 'ok' : 'warn', ok ? 'XML is valid (urlset root)' : 'XML valid but unexpected root');
    return ok;
  } catch (e) { t('err', 'Validation failed'); return false; }
}
function validateRobots(){
  const val = (getEditorValue('robotsOutput') || (document.getElementById('robotsOutput') || {}).value || '').toLowerCase();
  const hasUA = val.includes('user-agent');
  const hasSM = val.includes('sitemap:');
  if (hasUA && hasSM) { t('ok', 'Robots looks OK'); return true; }
  if (!hasUA && !hasSM) { t('warn', 'Missing User-agent and Sitemap'); return false; }
  t('warn', !hasUA ? 'Missing User-agent' : 'Missing Sitemap');
  return false;
}
function validateMeta(){
  const frag = getEditorValue('metaOutput') || (document.getElementById('metaOutput') || {}).value || '';
  try {
    const parser = new DOMParser();
    const doc = parser.parseFromString(`<head>${frag}</head>`, 'text/html');
    const hasDesc = !!doc.querySelector('meta[name="description"]');
    const hasTitle = !!doc.querySelector('title');
    const ok = hasDesc && hasTitle;
    t(ok ? 'ok' : 'warn', ok ? 'Meta looks OK' : 'Missing <title> or description');
    return ok;
  } catch (_) { t('err', 'Validation failed'); return false; }
}

// Beautifiers removed (no longer used)

// Copy/Download glue
function copySitemap(){ copyFromTextarea('sitemapOutput', 'Sitemap copied'); }
function copyRobots(){ copyFromTextarea('robotsOutput', 'Robots.txt copied'); }
function copyMetaTags(){ copyFromTextarea('metaOutput', 'Meta tags copied'); }
function downloadSitemap(){ const c = (getEditorValue('sitemapOutput')) || ''; downloadFile('sitemap.xml', c, 'application/xml'); }
function downloadRobots(){ const c = (getEditorValue('robotsOutput')) || ''; downloadFile('robots.txt', c, 'text/plain'); }
function downloadMetaTags(){ const c = (getEditorValue('metaOutput')) || ''; downloadFile('meta-tags.html', c, 'text/html'); }

// Expose to window for inline attributes
window.generateSitemap = generateSitemap;
window.generateRobots = generateRobots;
window.generateMetaTags = generateMetaTags;
window.copySitemap = copySitemap;
window.copyRobots = copyRobots;
window.copyMetaTags = copyMetaTags;
window.validateSitemap = validateSitemap;
window.validateRobots = validateRobots;
window.validateMeta = validateMeta;
window.downloadSitemap = downloadSitemap;
window.downloadRobots = downloadRobots;
window.downloadMetaTags = downloadMetaTags;

// Make state discoverable to UI overlay for editor
window.__seoToolState = state;

// Expose a small helper to update preview when external edits occur
window.__seoUpdatePreview = function(id){
  try { const ta = document.getElementById(id); const val = ta ? (ta.value || '') : ''; setEditorValue(id, val); } catch (_) {}
}
